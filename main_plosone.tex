% Template for PLoS
% Version 3.1 February 2015
%
% To compile to pdf, run:
% latex plos.template
% bibtex plos.template
% latex plos.template
% latex plos.template
% dvipdf plos.template
%
% % % % % % % % % % % % % % % % % % % % % %
%
% -- IMPORTANT NOTE
%
% This template contains comments intended 
% to minimize problems and delays during our production 
% process. Please follow the template instructions
% whenever possible.
%
% % % % % % % % % % % % % % % % % % % % % % % 
%
% Once your paper is accepted for publication, 
% PLEASE REMOVE ALL TRACKED CHANGES in this file and leave only
% the final text of your manuscript.
%
% There are no restrictions on package use within the LaTeX files except that 
% no packages listed in the template may be deleted.
%
% Please do not include colors or graphics in the text.
%
% Please do not create a heading level below \subsection. For 3rd level headings, use \paragraph{}.
%
% % % % % % % % % % % % % % % % % % % % % % %
%
% -- FIGURES AND TABLES
%
% Please include tables/figure captions directly after the paragraph where they are first cited in the text.
%
% DO NOT INCLUDE GRAPHICS IN YOUR MANUSCRIPT
% - Figures should be uploaded separately from your manuscript file. 
% - Figures generated using LaTeX should be extracted and removed from the PDF before submission. 
% - Figures containing multiple panels/subfigures must be combined into one image file before submission.
% For figure citations, please use "Fig." instead of "Figure".
% See http://www.plosone.org/static/figureGuidelines for PLOS figure guidelines.
%
% Tables should be cell-based and may not contain:
% - tabs/spacing/line breaks within cells to alter layout or alignment
% - vertically-merged cells (no tabular environments within tabular environments, do not use \multirow)
% - colors, shading, or graphic objects
% See http://www.plosone.org/static/figureGuidelines#tables for table guidelines.
%
% For tables that exceed the width of the text column, use the adjustwidth environment as illustrated in the example table in text below.
%
% % % % % % % % % % % % % % % % % % % % % % % %
%
% -- EQUATIONS, MATH SYMBOLS, SUBSCRIPTS, AND SUPERSCRIPTS
%
% IMPORTANT
% Below are a few tips to help format your equations and other special characters according to our specifications. For more tips to help reduce the possibility of formatting errors during conversion, please see our LaTeX guidelines at http://www.plosone.org/static/latexGuidelines
%
% Please be sure to include all portions of an equation in the math environment.
%
% Do not include xtext that is not math in the math environment. For example, CO2 will be CO\textsubscript{2}.
%
% Please add line breaks to long display equations when possible in order to fit size of the column. 
%
% For inline equations, please do not include punctuation (commas, etc) within the math environment unless this is part of the equation.
%
% % % % % % % % % % % % % % % % % % % % % % % % 
%
% Please contact latex@plos.org with any questions.
%
% % % % % % % % % % % % % % % % % % % % % % % %

\documentclass[10pt,letterpaper]{article}
\usepackage[top=0.85in,left=2.75in,footskip=0.75in]{geometry}

% Use adjustwidth environment to exceed column width (see example table in text)
\usepackage{changepage}

% Use Unicode characters when possible
\usepackage[utf8]{inputenc}

% textcomp package and marvosym package for additional characters
\usepackage{textcomp,marvosym}

% fixltx2e package for \textsubscript
\usepackage{fixltx2e}

% amsmath and amssymb packages, useful for mathematical formulas and symbols
\usepackage{amsmath,amssymb}

% cite package, to clean up citations in the main text. Do not remove.
\usepackage{cite}

% Use nameref to cite supporting information files (see Supporting Information section for more info)
\usepackage{nameref,hyperref}

% line numbers
\usepackage[right]{lineno}

% ligatures disabled
\usepackage{microtype}
\DisableLigatures[f]{encoding = *, family = * }

% rotating package for sideways tables
\usepackage{rotating}

\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{enumerate}
\usepackage{csvsimple}
\usepackage{parskip}
\usepackage[table,svgnames]{xcolor}
\usepackage[english]{babel}
\usepackage{minted}
\usepackage{boxedminipage}
% \usepackage[margin=1.5cm, includefoot, footskip=30pt]{geometry}
\newcommand{\matlab}[1]{\mintinline{matlab}{#1}}

% Remove comment for double spacing
% \usepackage{setspace} 
% \doublespacing

% Text layout
\raggedright
\setlength{\parindent}{0.5cm}
\textwidth 5.25in 
\textheight 8.75in

% Bold the 'Figure #' in the caption and separate it from the title/caption with a period
% Captions will be left justified
\usepackage[aboveskip=1pt,labelfont=bf,labelsep=period,justification=raggedright,singlelinecheck=off]{caption}

% Use the PLoS provided BiBTeX style
\bibliographystyle{plos2015}

% Remove brackets from numbering in List of References
\makeatletter
\renewcommand{\@biblabel}[1]{\quad#1.}
\makeatother

% Leave date blank
\date{}

% Header and Footer with logo
\usepackage{lastpage,fancyhdr,graphicx}
\usepackage{epstopdf}
\pagestyle{myheadings}
\pagestyle{fancy}
\fancyhf{}
\lhead{\includegraphics[width=2.0in]{figures/PLOS-submission.eps}}
\rfoot{\thepage/\pageref{LastPage}}
\renewcommand{\footrule}{\hrule height 2pt \vspace{2mm}}
\fancyheadoffset[L]{2.25in}
\fancyfootoffset[L]{2.25in}
\lfoot{\sf PLOS}

%% Include all macros below

\newcommand{\lorem}{{\bf LOREM}}
\newcommand{\ipsum}{{\bf IPSUM}}

%% END MACROS SECTION


\begin{document}
\vspace*{0.35in}

% Title must be 250 characters or less.
% Please capitalize all terms in the title except conjunctions, prepositions, and articles.
\begin{flushleft}
{\Large
\textbf\newline{DataJoint: managing big scientific data using MATLAB or Python}
}
\newline
% Insert author names, affiliations and corresponding author email (do not include titles, positions, or degrees).
\\
Dimitri Yatsenko\textsuperscript{1,*,\ddag}, 
Jacob Reimer\textsuperscript{1}, 
Alexander S.~Ecker\textsuperscript{1,2,3}, 
Edgar Y.~Walker\textsuperscript{1},
Fabian Sinz\textsuperscript{1}, 
Philipp Berens\textsuperscript{1,2,4}, 
Andreas Hoenselaar\textsuperscript{5}, 
R.~James Cotton\textsuperscript{1}, 
Athanassios G.~Siapas\textsuperscript{5}, 
Andreas S.~Tolias\textsuperscript{1}
\\
\bigskip
\bf{1} Baylor College of Medicine, Houston, Texas, USA
\\
\bf{2} Bernstein Center for Computational Neuroscience, Center for Integrative Neuroscience and Institute for Theoretical Physics, University of Tübingen, Germany
\\
\bf{3} Max Planck Institute for Biological Cybernetics, Tübingen, Germany
\\
\bf{4} Institute of Ophthalmic Research, University of Tübingen, Germany
\\
\bf{5} California Institute of Technology, Pasadena, USA
\\
\bigskip

% Insert additional author notes using the symbols described below. Insert symbol callouts after author names as necessary.
% 
% Remove or comment out the author notes below if they aren't used.
%
% Primary Equal Contribution Note
% \Yinyang These authors contributed equally to this work.

% Additional Equal Contribution Note
% Also use this double-dagger symbol for special authorship notes, such as senior authorship.
% \ddag These authors also contributed equally to this work.

% Current address notes
\ddag One Baylor Plaza, Suite S553, Houston 77030, Texas, USA
% \textcurrency b Insert current address of second author with an address update
% \textcurrency c Insert current address of third author with an address update

% Deceased author note
% \dag Deceased

% Group/Consortium Author Note
% \textpilcrow Membership list can be found in the Acknowledgments section.

% Use the asterisk to denote corresponding authorship and provide email address in note below.
* yatsenko@cns.bcm.edu

\end{flushleft}
% Please keep the abstract below 300 words
\section*{Abstract}
The rise of big data in modern research poses serious challenges for data management: Large and intricate datasets from diverse instrumentation must be precisely aligned, annotated, and processed in a variety of ways to extract new insights. 
While high levels of data integrity are expected, research teams have diverse backgrounds, are geographically dispersed, and rarely possess a primary interest in data science. 
Here we describe DataJoint, an open-source toolbox designed for manipulating and processing scientific data under the relational data model. 
Designed for scientists who need a flexible and expressive database language with few basic concepts and operations, DataJoint facilitates multi-user access, efficient queries, and distributed computing. 
With implementations in both MATLAB and Python, DataJoint is not limited to particular file formats, acquisition systems, or data modalities and can be quickly adapted to new experimental designs. 
DataJoint and related resources are available at \url{http://datajoint.github.com}.


% Please keep the Author Summary between 150 and 200 words
% Use first person. PLOS ONE authors please skip this step. 
% Author Summary not valid for PLOS ONE submissions.   
\section*{Author Summary}
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Curabitur eget porta erat. Morbi consectetur est vel gravida pretium. Suspendisse ut dui eu ante cursus gravida non sed sem. Nullam sapien tellus, commodo id velit id, eleifend volutpat quam. Phasellus mauris velit, dapibus finibus elementum vel, pulvinar non tellus. Nunc pellentesque pretium diam, quis maximus dolor faucibus id. Nunc convallis sodales ante, ut ullamcorper est egestas vitae. Nam sit amet enim ultrices, ultrices elit pulvinar, volutpat risus.

\linenumbers

\section*{Introduction}
Data emerging from today's biological experiments are not merely ``big'' but increasingly multimodal and dynamic, as projects quickly move to new technologies and experimental paradigms \cite{howe_big_2008, maze_analytical_2014, editorial_focus_2014, anderson_issues_2007, kandel_neuroscience_2013, gray_scientific_2005}.
In our field of neuroscience, a single experiment may involve several signal acquisition modalities such as imaging, multi-channel electrophysiology, genetic sequencing, optical stimulation, behavioral recordings, and an array of other techniques \cite{reimer_pupil_2014,froudarakis_population_2014}.

Concerted effort must be applied to maintain the integrity and reproducibility of scientific findings by keeping data intelligible and uncorrupted over months and years of experiments.
Data shared between research groups are particularly susceptible to confusion and corruption during data transfers and concurrent access. 
Data integrity must be preserved when it is accessed by multiple computers performing parallel and distributed computations in scenarios such as cluster or cloud computing, even when some jobs are interrupted.

Flexible data access can greatly increase productivity during data analysis to obtain specific cross-sections stored data based on diverse criteria from multiple datasets as in the case of summary statistics across multiple experiments.
When using the file system for organizing data, such analysis may require traversing folders and files, parse their contents, and select and assemble the necessary data for each analysis \cite{anderson_issues_2007}.
Changing experimental configurations require careful adaptations in the structure of associated data repositories and tedious reconfiguration of analysis scripts.

In contrast to file systems, relational databases explicitly maintain data integrity and offer flexible access to cross-sections of the data \cite{codd_relational_1970}. 
A relational database preserves consistency and referential integrity even as multiple users and processes manipulate data concurrently or if a process terminates unexpectedly.
Unlike a file system, a database is not an inert repository designed to simply reproduce data in their original form: instead, it provides a way to access specific and precise cross-sections of the data in order to answer questions unforeseen at the time the data are deposited.
A database system also defines and enforces real-world constraints and relationships between data elements, even as experimental paradigms change over time.
It communicates and enforces these relationships because they are inherent in the structure of the data itself.
This form of self-documentation enables new users to readily understand the architecture of an unfamiliar data set.

Here we describe an open-source framework, DataJoint, to help scientists organize, populate, and query large volumes of data.
In contrast to existing database systems and query languages which are overgrown with extraneous complexity \cite{date_sql_2011,manyam_relax_2012},
DataJoint introduces a minimal set of operators that allow flexible, efficient, and expressive queries to retrieve exactly the data one needs.
Unlike other domain-specific data management tools \cite{manyam_relax_2012, gunay_database_2009, schutter_review_2009, small_database-managed_2009, brown_overview_2010, shi_synapticdb_2011, pittendrigh_neurosys_2003}, DataJoint is general and extensible, as it is not tied to particular file formats, acquisition systems, or data modalities.
At its back end, DataJoint is powered by the flexible and scalable open-source relational database management system MySQL (or its equivalents such as MariaDB).
However, DataJoint users do not need to learn SQL. They can manipulate data transparently through two of the most popular languages for scientific data analysis: Python and MATLAB.
Data can be concurrently accessed and manipulated by multiple users using either language, or distributed across multiple computers for parallel processing.

\section*{Materials and Methods}
\subsection*{Defining data elements}

\begin{figure*}
\begin{tabular}{p{0.5\textwidth}p{0.5\textwidth}}
{\sf \large A} & {\sf \large B}
\\
\vspace{0pt}\includegraphics{./figures/experiment.pdf} &
\vspace{0pt}\includegraphics{./figures/schema.pdf}
\\
\end{tabular}

{\sf \large C}
\vspace{6pt}

\inputminted[frame=single,linenos=true]{python}{Session.py}

\vspace{6pt}
{\sf \large D}
\vspace{6pt}

\csvreader[
table head = \hline\bf animal & \bf session & \bf user & \bf session\_date & \bf session\_folder & \bf notes & \bf timestamp\\\hline,
before table=\rowcolors{1}{white}{Beige},
table foot = \hline,
head to column names,
tabular=|cc|lllll|
]{session.csv}{}%
{\tt\animal & \tt\session & \tt\user & \tt\date & \tt\folder & \tt\notes & \tt\ts}
\caption{
{\bf An example experiment and its DataJoint schema.}
{\sf A.}  
A neuroscience experiment with multiple stimulation and acquisition modalities (counterclockwise from top left corner): fluorescence imaging of calcium signals (Ca$^{2+}$), light stimulation of optogenetic probes, visual stimulus, treadmill motion recording, local-field potential recording (LFP), whole-cell patch membrane potential recording (V\textsubscript{m}), video of whisker movements, video of eye movements.
{\sf B.}  The entity relationship diagram (ERD) of a DataJoint schema comprising base relations storing externally entered data (green) and automatically populated data (red).
{\sf C.}  
The Python class for the base relation \mintinline{python}{Session} specifying the relation's heading. 
A dependency on \mintinline{python}{Animal} is indicated with the arrow {\tt-\textgreater}.  
An additional primary key attribute, {\tt session}, enables multiple sessions per animal. 
Dependent attributes are separated from primary key attributes by {\tt---}.   
Each attribute has a name, an optional default value, a datatype, and an optional comment.
{\sf D.}  
Example contents of \mintinline{python}{Session}.
The vertical divider separates the primary key attributes `{\tt animal}' and `{\tt session}` from the dependent attributes.
} 
\label{schema}
\end{figure*}

Consider a particular real-world neuroscience study comprising a series of experiments that involve simultaneous \emph{in vivo} recordings of several types of physiological signals (whole-cell membrane potential or V\textsubscript{m}, local-field potentials or LFP, and calcium fluorescence signals), stimuli (visual display and optogenetic stimulation of targeted neuronal populations), and behaviors (locomotion, whisking, eye movements) \cite{reimer_pupil_2014}. 
Figure \ref{schema}\,A illustrates such an experiment.

To work with data from such studies, DataJoint users create a \emph{schema} (or several schemas) comprising a collection of \emph{base relations} to represent the various elements of the experiments (Fig.\ \ref{schema}\,B).
Relations are DataJoint's basic data representation and can be thought of as simple tables with a \emph{heading} and a \emph{body}.
The heading specifies attribute names and datatypes. 
The body comprises a set of \emph{tuples} of attribute values. 
Base relations are stored in the database whereas \emph{derived relations} may be constructed from base relations for data queries.
For detailed definitions of the Relational Data Model, see Table \ref{glossary}.

\begin{table*}
\begin{boxedminipage}{\textwidth}
\section*{Relational Data Model}
\begin{description}
\setlength\itemsep{6pt}
\item[Relation] 
All data are represented as \emph{relations}.  A relation can be visualized as a table or a shreadsheet.  
It consists of a \emph{heading} with attribute names and datatypes and a \emph{body} comprising a set of \emph{tuples} with values for each attribute.

\begin{center}
\includegraphics{./figures/relation.pdf}
\end{center}

We distinguish between \emph{base relations} and \emph{derived relations}.  
A base relation has a dedicated class in MATLAB or Python and represents data stored directly in the database.
Derived relations are formed from other relations by using relational operators (See Table \ref{algebra}).
To create a new base relation, users create a new MATLAB or Python class subclassing from the DataJoint Relation class and define the relation's heading. 
After that, users interact with the data by invoking these relation classes.

\item[Schema] A schema is a named collection of related base relations. 
A single project may store data across multiple schemas. Conversely, many schemas can be used for data shared by multiple projects.

\item[Query] Queries retrieve the data represented by a relation into the MATLAB or Python workspace.

\item[Primary key] Every relation has a primary key: a subset of its of attributes that uniquely identify each of its tuples. 
Two tuples with the same values of the primary key attributes cannot coexist in the same relation.
The remaining attributes in the relation are called dependent attributes. 
When one relation includes some attributes that also belong to the primary key of another relation, they determine how tuples are grouped and related between the two relations.

\item[Dependencies]
Base relations may form dependencies by referencing one another. 
Every tuple in a dependent relation must have a matching tuple in the relations references by the dependency. 
Dependencies may cross schema boundaries.

\item[ERD]
The entity relationship diagram or ERD is a graphical representation of base relations and their dependencies.
Fig.\ \ref{schema}\,B depicts the ERD for a particular neuroscience experiment. 
\end{description}
\end{boxedminipage}
\caption{Key concepts of the relational data model as used in DataJoint.}
\label{glossary}
\end{table*}

A base relation is created in the form of a class in MATLAB or Python (Fig.\ \ref{schema}\,C) that defines the relation's heading.
The heading definition comprises a description of the relation, dependencies on other base relations, and a set of \emph{attributes}. 
Each attribute has a name, an optional default value, a datatype, and an optional description.
Attributes that comprise the \emph{primary key} of the relation are separated from the remaining attributes by the divider {\tt---}.

DataJoint provides all the functionality for accessing and manipulating data through the base relation classes. 

\subsection*{Defining dependencies}
The database must respect dependencies between data elements and prevent incomplete, orphaned, or mismatched data.
DataJoint facilitates setting, enforcing, and displaying data dependencies. 
The edges of the graph in the entity relationship diagram (ERD) in Fig.\ \ref{schema}\,B denote dependencies directed downward: relations below are dependent on relations above when connected.
Chains of dependencies effectively set the order in which  data must be populated. 
Thus the ERD serves as an effective communication tool for the overall data organization and the sequence of steps to be followed for data entry and  processing.
Each base relation can depend on multiple other relations but the dependency graph must be acyclic: a relation cannot depend on itself or on other relations that depend on it directly or through other relations.

To create a dependency, the dependent relation's data definition must include the line \matlab{-> Reference}, where \matlab{Reference} is the class name of the referenced base relation.

Setting a dependency has two effects:
\begin{enumerate}[(a)]
\item the primary key attributes of the referenced relation are copied into the definition 
\item a foreign key constraint is created to the referenced relation.
\end{enumerate}

The foreign key constraint causes the database to reject any new tuple in the dependent relation unless there exists a matching tuple in the referenced relation. 
Conversely, deleting a tuple from the referenced relation will cause all matching tuples in all the dependent relations to be deleted too.

For example, when \matlab{Session} depends on \matlab{Animal} (Fig.\ \ref{schema}\,B),
\matlab{Animal}'s primary key attribute {\tt animal} is automatically included in \matlab{Session}'s heading (Fig.\ \ref{schema}\,C and D). 
A new session cannot be entered for an animal that has not yet been entered;  and when an animal is deleted, all its sessions will be  deleted as well, along with all the dependent data below in the hierarchy.

Importantly, DataJoint treats tuples in relations as indivisible; dependencies are established between whole tuples rather than between attribute values.
DataJoint methods modify relations only by inserting or deleting entire tuples and cannot update individual attribute values independently.

Such discipline guarantees that any changes of attribute values will trigger recomputation of all dependent data. 
Of course, users can deliberately intervene and modify values manually to bypass dependencies when necessary, provided that they have been granted update privileges by the database administrator.

The primary keys and dependencies between base relations allow defining a rich variety of relationships between data elements.  
Three common types of relationships illustrate this point (Figure \ref{dep}). 

\begin{figure*}[h]
\begin{center}
\begin{tabular}{p{0.2\textwidth}p{0.2\textwidth}p{0.4\textwidth}}
{\sf \large A} &
{\sf \large B} &
{\sf \large C} \\
\vspace{0pt} \includegraphics{./figures/depA.pdf} &
\vspace{0pt} \includegraphics{./figures/depB.pdf} &
\vspace{0pt} \includegraphics{./figures/depC.pdf}
\end{tabular}
\end{center}
\caption{
{\bf Three common replationships defined through the dependencies and primary keys of base relations.}
{\sf A.} A one-to-one relationship.
{\sf B.} A one-to-many (hierarchical) relationship.
{\sf C.} A combinatorial relationship. 
}
\label{dep}
\end{figure*}


\begin{itemize}
\item
In a one-to-one relationship (Fig.\ \ref{dep}\,A), relation \matlab{Child} declares a dependency within its primary key on \matlab{Parent} but does not add any new attributes to its primary key.
Thus the primary key for \matlab{Child} is the same as for \matlab{Parent}: only one tuple in \matlab{Child} can exists for each tuple in \matlab{Parent}.
\item
In a one-to-many relationship (Fig.\ \ref{dep}\,B), relation \matlab{Child} declares a dependency within its primary on \matlab{Parent} but also declares an additional attribute \matlab{child_id} in its primary key, which allows \matlab{Child} to have multiple tuples matching each tuple in \matlab{Parent}.
\item
In a combinatorial relationship (Fig.\ \ref{dep}\,C), relation \matlab{Child} declares a dependency within its primary key on  multiple relations.
In this example, \matlab{Child}'s primary key combines the primary key attributes from both \matlab{Parent1} and \matlab{Parent2}.  
This means that \matlab{Child} holds tuples corresponding to any combination of tuples in \matlab{Parent1} and \matlab{Parent2}.
\end{itemize}
Examples of other types of relationships may be found in the online resources.

\subsection*{Querying data}
DataJoint provides a minimal yet powerful set of operators on relations: restriction, projection, and join.
These operators allow transforming relations into new derived relations. 
Table \ref{algebra} summarizes these operators.
\begin{table*}
\begin{boxedminipage}{\textwidth}
\section*{Relational algebra}

Relational operators operate on existing relations to produce \emph{derived} relations for answering a wide variety of specific queries.
These operators do not retrieve any data from the database until the resulting expression is used to \emph{fetch} the data.
Relational operators are based on the concept of \emph{matching tuples}: 
Two tuples are considered matching  \emph{unless} they share an attribute with the same name but different values.

\subsection*{Restriction:  {\sf A \& B}, {\sf A -- B}}
The restriction A\&B denotes a relation comprising all tuples from A that match any tuple in {\sf B}.  

\begin{center}
\includegraphics{./figures/restriction.pdf}
\end{center}

The inverse restriction {\sf A--B} denotes all tuples from {\sf A} that do not match any tuple in {\sf B}.

\begin{center}
\includegraphics{./figures/antijoin.pdf}
\end{center}


\subsection*{Join: {\sf A * B}}
The join {\sf A*B} is the set of all tuples that can be produced by merging matching tuples from {\sf A} and {\sf B}:

\begin{center}
\includegraphics{./figures/join.pdf}
\end{center}
All attributes in {\sf A} and {\sf B} that share the same names must belong to the primary key in either relation.

\subsection*{Projection: {\sf A.pro(attributes)}}
The projection {\sf A.pro(attributes)} modifies the heading of {\sf A} by selecting a subset of its attributes (project), renaming attributes (rename), computing new attributes (expand), and computing summary statistics from other relations (aggregate).
The primary key attributes cannot be excluded from the resulting relation but may be renamed. 

\begin{center}
\includegraphics{./figures/project.pdf}
\end{center}

Please refer to the online documentation for more detailed descriptions.
\end{boxedminipage}
\caption{Relational operators of DataJoint}
\label{algebra}
\end{table*}

The output of each relational operator is a proper relation in its own right with its primary key, uniquely named attributes, and the full range of data query methods.
This property, called \emph{algebraic closure}, allows expressings highly specific queries from existing queries intuitively and laconically.

The starting point of any relational expression are base relations represented by their classes. 
For example, after executing the following assignment in either Python or MATLAB,
\mint{matlab}|rel = Ephys()|
the variable \matlab{rel} will represent the contents of the base relation \matlab{Ephys}, which represents electrophysiological recordings: local field potentials and spikes in our schema  (Fig.\ \ref{schema}\,B).

Restriction (represented by the logical AND operator {\tt \&}) selects a subset of tuples based on some condition.
For example, \matlab{Animal} may be restricted by a structure specifying values of attributes \matlab{species} and \matlab{sex},
in MATLAB,
\begin{minted}{matlab}
r.species = 'mouse'
r.sex = 'M'
\end{minted}
or in Python
\begin{minted}{python}
r = dict(species='mouse', sex='M')
\end{minted}
to produce the relation containing all male mice,
\mint{matlab}|male_mice = Animal() & r|

Relations can be restricted by conditions in the form of character strings, structures or structure arrays, or other relations.
For example, other relations may be restricted with \matlab{male_mice} even in combination with other restrictions:
\mint{matlab}|rel = Ephys() & male_mice & 'sampling_rate > 10000'|
The result \matlab{rel} will represent all Ephys recordings from male mice with acquisition sampling rates above 10 kHz when \matlab{sampling_rate} is an attribute of \matlab{Ephys}.


As another example, the relation \matlab{Running} contains episodes of the animals' locomotion inferred from treadmill sensor recordings in relation \matlab{Treadmill}.
Then the restriction
\mint{matlab}|rel = Session() & Running()|
represents all sessions with at least one episode of running.

Restrictions can also take the negative form using the \matlab{-} (minus) operator. For example,
\mint{matlab}|rel = (LFP() & Treadmill()) - Running()|
contains all LFP recordings in sessions that included treadmill recordings but no running episodes where found.

The join operator (\matlab{*}) produces a relation comprising all possible combinations of matching tuples from its two argument relations.

For example, the relation
\mint{matlab}|rel = Spikes() * LFP()|
will contain both spiking and LFP data for the same \matlab{Ephys} recordings.

Relational operators can be combined to produce highly specific expressions.  
For example,
\begin{minted}{matlab}
rel = Spikes() * LFP() & (Animal() * Session() & 
   'datediff(session_date, date_of_birth)<=28')
\end{minted}
is similar to the previous example but the result is restricted to cases when the animals were 28 days old or younger at the start of the recording session.
Since DataJoint passes its restriction conditions to SQL, restrictions can call SQL functions such as \matlab{datediff} here for computing the difference between the dates. 
Note that \matlab{session_date} comes from \matlab{Session} whereas \matlab{date_of_birth} comes from \matlab{Animal}. 
Thus the relation \matlab{Animal*Session} has both dates required for calculating the age. 

The \emph{projection} operator allows selecting and renaming attributes as well as computing new attributes, including summary statistics on other relations.  Please refer to the online documentation for additional details.

Relation objects are only symbolic representations of the data and relational expressions are only symbolic manipulations.
Once the desired relation is formulated, the actual data are retrieved from the database into a structure array using the \matlab{fetch} method
\mint{matlab}|data = rel.fetch()|

\subsection*{Entering and computing data}
DataJoint distinguishes between \emph{manual} and \emph{automated} base relations. 
In the entity relationship diagram (Fig.\ \ref{schema}\,B), manual base relations are displayed as green nodes whereas automated base relations are displayed in red.

Manual base relations contain data entered by the experimenter or by acquisition software.
They store data that are derived from external sources and are typically at the head of the dependency hierarchy.
Users commonly edit manual relations directly in the form of a spreadsheet using third-party interfaces such as MySQL Workbench, Navicat, SequelPro, HeidiSQL, and others. 

Automated base relations are filled automatically from MATLAB or Python with the help of their \matlab{populate} method. 
For example, Figures \ref{power-m} and \ref{power-py} list the complete implementation of the \matlab{Power} base relation, which computes the average power of the LFP signal for various frequency bands in our schema (Fig.\ \ref{schema}\,B).

\begin{figure*}
\inputminted[frame=single,linenos=true]{matlab}{Power.m}
\caption{The class for the base relation \matlab{Power} in MATLAB.}
\label{power-m}
\end{figure*}

\begin{figure*}
\inputminted[frame=single,linenos=true]{python}{power.py}
\caption{The class for the base relation \matlab{Power} in Python.}
\label{power-py}
\end{figure*}

Execution of the following commands will fill \matlab{Power} for all available data.
\begin{minted}{python}
rel = Power()
rel.populate()
\end{minted}

The \matlab{populate} method always ``knows'' what needs to be computed using the base relation's dependencies.
It compares the contents of the base relation to those of its immediate neighbors upstream in the dependency hierarchy. 
The job list is defined as the join of the immediate upstream neighbors of the populated relation \emph{minus} the population itself.

For example, \matlab{Power} depends on \matlab{LFP} and \matlab{FrequencyBand}. 
Then the restricted join 
\mint{matlab}|missing = LFP() * FrequencyBand() - Power()|
will express  all combinations of tuples in \matlab{LFP} and \matlab{FrequencyBand} for which \matlab{Power} does not yet have any entries.
Each tuple in \matlab{missing} specifies an isolated job to be performed for \matlab{Power}.
This logic is implemented internally and is provided here only to help users understand what happens under the hood of a \matlab{populate} call.

When \matlab{rel.populate()} is called, it executes  \matlab{rel.makeTuples(key)} (in MATLAB) or \matlab{rel._make_tuples(key)} (in Python) for the primary key value  of each tuple in \matlab{missing}.

Users specify the computation of new tuples for each item in \matlab{missing} using the \emph{make-tuples} callback method (Figures \ref{power-m} or \ref{power-py}),
which consists of three parts: 
\begin{enumerate}
\item fetch the required data from other relations upstream in the dependency hierarchy, always restricting by the argument \matlab{key},
\item use fetched data to compute attributes of the relation that are missing in \matlab{key},
\item create new tuples that combine the newly computed attributes and \matlab{key} and submit them to the database using the \matlab{insert} method.
\end{enumerate}

Each \emph{make-tuples} call runs inside an isolated \emph{transaction} so that its results  do not become visible to other processes until the entire call completes successfully. 
If an error occurs during a \emph{make-tuples} call, any partially populated data are discarded and never become visible to downstream computations.

The \matlab{populate} method has several options to control its behavior. 
In particular, it has the option of using the built-in \emph{job reservation} process to enable efficient distributed execution. 
With job reservation enabled, users simply execute \matlab{populate} on multiple computers to run the \emph{make-tuples} jobs in parallel  without conflicts.
Please refer to the online documentation for \matlab{populate} options and various techniques for customizing the processing chains.

\subsection*{Sharing data and distributed computation}
Through the features described above, DataJoint naturally supports collaboration and distributed access by
\begin{itemize}
\item setting, enforcing, and communicating dependencies between data elements,
\item keeping data definition and computation code together in the same class for easy review and sharing,
\item storing and organizing data in a popular database management system (MySQL) that can be accessed through a variety of third-party interfaces,
\item allowing safe simultaneous access to the same data through standard transaction processing provided by MySQL, and
\item providing an automatic and transparent job reservation process for conflict-free distributed processing.
\end{itemize}

\section*{Discussion}
The relational data model has served as the theoretical foundation for the majority of mainstream  database systems for over forty years and has been shown to be the most cogent and principled approach for representing and manipulating data of arbitrary complexity \cite{date_sql_2011}.
Yet, relational organization of data in science labs is still uncommon. 
This disconnect is partly due to SQL's  position as the only wide-spread implementation of the relational model. 
SQL and its dialects have deviated substantially from the simplicity of the relational data model and have overgrown with extraneous complexity.

Object-relational mappers (ORM) are software tools that map objects in computer memory to persistent storage such as relational databases.
Since DataJoint constructs objects with persistently stored data, it can be classified as an ORM.
Several other object-relational mappers are available for Python: SQLAlchemy, Django ORM, Peewee, PonyORM, SQLObject.
They take a similar approach of converting objects and idioms of the host programming language into SQL queries for processing by the database server.
We are not aware of any ORM tools for MATLAB besides DataJoint.

DataJoint addresses other needs than ORMs: it is specifically designed for providing a robust and intuitive data model for scientific data processing chains.
As such, it does not attempt to simply mirror the features and capabilities of SQL.
Instead, DataJoint imposes constraints and conventions to achieve the expressive power and simplicity of queries by strict adherence to the relational data model.
In science, both the structure of the data and the queries evolve frequently. 
A simple, sound data model is of greater importance than in other database applications.

Some of the distinct constraints imposed by DataJoint include the following:
\begin{enumerate}

\item
All data are represented as proper relations with a primary key and uniquely named attributes. 
This applies to base and derived relations. 
Relational operators follow consistent rules for determining the primary key of its result. 
As a result, DataJoint's operators are algebraically closed, allowing building complex expressions from simpler expressions.

\item
Data in base relations are updated only by inserting or deleting entire tuples: updates of attribute values are not supported.
As discussed in the text, this limitation is necessary because referential constraints (foreign keys) enforce data dependencies only between tuples and not between individual attribute values. 

\item 
Dependencies between base relations are acyclic, \emph{i.e.}\ they cannot form loops. 
This restriction simplifies data definition but, perhaps counter-intuitively, does not prevent specifying arbitrary relationships between data elements, including directed graphs with cyclic dependencies, for example.

\item
DataJoint limits relational operators to enforce clarity.
For example, the projection operator (see Table \ref{algebra} and online documentation) does not allow projecting out the primary key attributes.
Consequently, the resulting relation has the same number of tuples as the original relation and every tuple is unique.
If the user does intend to derive a relation with a different primary key, she must explicitly declare a base relation with this primary key and use it to formulate the proper query.
In practice, this is not a real limitation but a specific prescription of how data must be defined and manipulated in a uniform and explicit manner.

\item
Foreign keys always link identically named attributes in both relations.
This convention simplifies the specification of dependencies and of relational operators.
For example, a single join operator in DataJoint can perform the same work as the multiple forms and parameterizations of the JOIN operators in SQL.
This convention is particularly important in DataJoint because it allows direct logical linking of relations separated by many intermediate dependencies.
In a large schema, this convention may lead to long composite primary keys low in the dependency hierarchy, but these are efficiently handled by MySQL's storage engines.

\end{enumerate}

DataJoint's restricted relational data model represents a conceptual shift in database interactions: In SQL queries, users explicitly enumerate and match individual attributes.
In contrast, DataJoint users formulate dependencies and queries at the level of entire relations.
As a result, DataJoint's fast, intuitive, and expressive data definition and manipulation languages enable scientists to flexibly adapt their data processing chains to evolving demands.

\subsection*{Examples and resources}
To benefit from DataJoint, users need not appreciate the various technical considerations underlying its capabilities.
We encourage interested readers to review the online documentation to get up and running with DataJoint quickly.
For tutorials, a gallery of working schemas for MATLAB and Python, documentation, and references to scientific papers using DataJoint, please visit \url{http://datajoint.github.com}.


\bibliography{datajoint}



\end{document}

